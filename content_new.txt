
\frametitle{Introduction}
SHOW
A picture of a network/messages
G,M,T

TALK
Our goal is to send a collection of messages throughout a network of switches. We model the network as a directed graph. Each message has a source and target vertex. Hardware limitations allow sending only one message at every time step on an edge.


\frametitle{Initial Work}
SHOW
An example of a time triggered (TT) schedule

Disadvantages
This assumes that the network is fixed.

TALK
We try to find a time-triggered (TT) schedule - which message is sent on each link at each time. In practice, this is done using an SMT program. 

Disadvantages
TT schedules assume that the network is fixed, and are not very fault tolerant. Before us, faults were usually handled by the application layer using redundant messages. Finding a TT schedule is very costly, and redundancy only makes the problem harder.

\frametitle{Previous Paper}
SHOW
TT Schedules
Adverserial Approach
Simple Error Recovery Protocol - If scheduled edge has crashed, forward on another edge
Comparing schedules:
	k-l resistance : At most k crashes, at least l messages arrive

crash : A link goes down permanently

TALK
In the previous paper we took an adversarial approach to faults. We assumed the switches run a simple error recovery protocol that is used once crashes occur. The switches follow the schedule if no crashes occur. When a crash occurs and a switch tries to forward a message on a crashed link, the protocol says on which other edge to forward the message. 

We dont want to find any schedule. We want to find a good one. For this, we need to be able to compare schedules. We define a (k,l)-resistant schedule: if at most k crashes occur, at least l messages arrive on time. 

\frametitle{Handling New Faults}
SHOW
Edge faults
	Permanent Crashes 
	Temporary Crashes
Message faults
	Message Losses

TT Schedules not good enough

TALK
We incorporate new types of faults. Explain briefly the faults. We realized that the TT Schedules are not the best way of handling such faults. We moved to a cleaner notion of forwarding.

\frametitle{Message Forwarding}
SHOW
3 Components:
- The path selection (Paths)
- The message priorities (Priority Scheme)
- The algorithm (Algorithm)

TALK
Now, we talk of 3 separate components of message forwarding. Given the message souce and targets, we decide the paths (and fallback paths) to be taken by the message (in case of crashes). Instead of a TT Schedule, each switch has priorities over which messages to send first. Given the path and the prioriteies, the algorithm takes care of which message to send where and when.

\frametitle{Problem Statement}
SHOW
Probabilistic model: p_crashes, p_omission
For a particular G,M,T,Paths,Algorithm
Score a Priority Scheme.
Score(Priority Scheme) = Probability(AMA)
 		AMA:The event that All Messages Arrive by time T

Solution: Count!

TALK
How the problem is a probabilistic one. What we are scoring. Stress on importance of counting

\frametitle{The Different Approaches}


\frametitle{The Naive Approach}
SHOW
A flowchart describing TALK

Additional SMT Constraint:
Total #crashes == k

Optimization:
Identify and add minimal sub-constraint

TALK
Encode the forwarding algorithm and the path protocol SAT Program which is SAT if there exists a sequence of crashes which result in $not(AMA)$

1. Use an SMT solver to get a solution, and the corresponding probability 
2. Add it's negation to the solver as a Constraint
3. Repeat this process until there is no solution left


Beacuse of the huge number of solutions that may exist, and the small probability of a large number of crashes occuring, we restrict the number of solutions by adding an SMT constraint:
#crashes == k
And incrementally solve for k = 0,1,2... , stopping whenever the user wants

Talk about optimization


\frametitle{Weighted Model Counting (WMC)}
SHOW
Generalization of SAT counting.
Weight(\sigma) = \product_{Literals l}{Weight(\sigma(l))}


\frametitle{Counting Techniques}
	Exact
	SharpSAT

	Approximate
	cryptominsat
