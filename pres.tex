\documentclass{beamer}
\usepackage{ifpdf}
\usepackage{grffile}
\usepackage{epsfig} % This package formats figures.
\usepackage{psfrag} % This package formats figures.
\usepackage{amsmath} % This is a package for math features.
\usepackage{amsfonts} % This is a package for math features.
\usepackage{amssymb} % This is a package for math features.
\usepackage{graphicx}
\usepackage{epstopdf}


\usetheme{CambridgeUS}
\begin{document}

\title[Probabilistic Networks]{Networks with Probabilistic Failures}
\subtitle[Probabilistically Scoring Message Priorities]{Scoring Message Priorities in Switched Networks with Probabilistic Failures}
\author[Shubham]{Shubham Goel}
\institute[IITB]{
  Indian Institute of Technology, Bombay\\[1ex]
}
\date[Summer 2016]{Summer 2016}

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}
\frametitle{Introduction}
	% A picture of a network/messages\\
	\begin{columns}
	\column{0.6\textwidth}
	\begin{description}
	\item[Switched Network] $\to$ G, Directed graph
	\item[Set of Messages] $\to$ M $\ni (source,target)$
	\item[Global Timeout] $\to$ t
	\end{description}
	\column{0.4\textwidth}
	\begin{figure}
	\includegraphics[scale=0.3]{media/digraph2.jpg}
	\caption{Network $\to$ DiGraph}
	\end{figure}
	\end{columns}
	\vspace*{20pt}
	Hardware Limitation : Only 1 message can be sent per link per time unit
\end{frame}

\begin{frame}
\frametitle{Initial Work}
	\framesubtitle{Time-Triggered (TT) schedules}

	\vspace*{-8pt}

	\begin{columns}
	\column{0.5\textwidth}
	\begin{figure}
	\includegraphics[scale=0.4]{media/digraph2.jpg}
	\caption{Network as a DiGraph}
	\end{figure}

	\column{0.5\textwidth}

	\begin{table}
	\begin{tabular}{c | c | c}
	Message & Source & Target\\
	\hline \hline
	m0 & v1 & v2\\ 
	m1 & v1 & v4
	\end{tabular}
	\caption{Messages}
	\end{table}

	\vspace*{-15pt}

	\begin{table}
	\begin{tabular}{c | c | c}
	Message & Edge & Time\\
	\hline \hline
	m0 & (1-2) & 0\\ 
	m1 & (1-2) & 1\\
	m1 & (2-4) & 2
	\end{tabular}
	\caption{A Time-Triggered Schedule}
	\end{table}
	\end{columns}


	\pause
	\color{red}

	\vspace*{-15pt}
	\begin{center}
	TT scheduling assumes that the network is fixed, is costly\\
	However, in practice, networks are faulty (discussed later)
	\end{center}
\end{frame}

\begin{frame}
\frametitle{Previous Paper - An Adverserial Approach}
	\begin{itemize}
	\item Time-Triggered Schedules
	\item Simple Error Recovery Protocol %- forward message on some other edge
	\item $(k,l)-resistance$:	\\
	If at most $k$ crashes occur, at least $l$ messages arrive\\[3ex]
	\end{itemize}
	\hspace*{20pt}$ crash $ : A link goes down permanently\\[3ex]
	\pause
	Can also be viewed as a saboteur game!\\[2ex]
	\pause
	\color{blue}
	We now study networks with probablistic faults.\\
	A more detailed specification ahead...
\end{frame}

\begin{frame}
\frametitle{Handling New Faults}
	\begin{itemize}
	\item Edge faults
	\begin{itemize}
		\item Permanent Crashes 
		\item Temporary Crashes
	\end{itemize}
	\item Message faults
	\begin{itemize}
		\item Message Delays
		\item Message Losses
		\begin{itemize}
			\item Modelled as: Message reappears at a vertex immediately after it was sent from it.\\[2ex]
		\end{itemize}
	\end{itemize}
	\end{itemize}
	\pause
	\begin{center}
	\color{red}
	Things become messy with Time-Triggered Schedules.\\We move to a cleaner notion of message forwarding.
	\end{center}
\end{frame}

\begin{frame}
\frametitle{Message Forwarding}
	\framesubtitle{Components}
	% \begin{enumerate}
	\begin{block}{Paths}
	For each message $ m\in M $, specify the possible paths that can be taken by $ m $
	\end{block}

	\begin{block}{Priority Scheme}
	Each vertex $ v $ has a total order $ \prec _{v} $ on the set of
	messages $ M $. $$\forall m_1,m_2 \in M,\ m_1\prec _{v}m_2 \implies m_1 \text{ has higher priority over } m_2 \text{ at } v$$
	\end{block}

	\begin{block}{Algorithm}
	Given $Paths$ \& $Priority\ Scheme$, the $Algortihm$ decides what messages are forwarded on each link.
	\end{block}
	% \end{enumerate}
\end{frame}

\begin{frame}
\frametitle{Problem Statement}
	\textbf{Given}:
	\begin{itemize}
		\item G, M, t
		\item $p_{crashes}$ = Pr(Edge Fault)
		\item $p_{omission}$ = Pr(Message Fault)
		\item Message Paths
		\item Forwarding Algorithm
		\item Priority Scheme\\[3ex]
	\end{itemize}
	\textbf{Find}:
	The score of the Priority Scheme, where\\
		$$Score(\text{Priority Scheme}) = \Pr(\text{All messages arrive by time t})$$
\end{frame}

% \begin{frame}
% \frametitle{The Different Approaches}
% \begin{enumerate}
% \item Naive Approach (+Optimization)
% \item Bit-Adder
% \item Weighted Model Counting
% \item Monte-Carlo Approach (+Multiprocessing)
% \end{enumerate}
% \end{frame}

\begin{frame}
\frametitle{The Naive Approach}
	Simulate the network (message forwarding) as a SAT Program : $ f $ \\[3ex]
	Every crash sequence \mapsto\ a unique assignment \sigma\  
	\vspace*{-5pt}
	$$ \sigma \vDash f \implies \neg(\text{All Message Arrive by time t}) $$
	\begin{block}{$\ $}
	$$ Score(\text{Priority Scheme}) = 1-\sum_{\sigma \vDash f}\Pr(\sigma) $$
	\end{block}
\end{frame}

\begin{frame}
\frametitle{The Naive Approach}
	
	SAT Program : $ f $ \\[3ex]
	\textbf{Finding the score}:\\
	Initialize $Score(\text{Priority Scheme}):=1$

	\begin{enumerate}
		\item Get a solution $\sigma$
		\item Calculate $\Pr(\sigma)$, subtract it from $Score(\text{Priority Scheme})$
		\item Add $\neg \sigma$ to the program as a constraint
		\item Repeat this process until there is no solution left\\[3ex]
	\end{enumerate}
	\pause
	\color{red}
	There may be too many solutions!\\
	A lot of them have negligible probabilities.\\
\end{frame}

\begin{frame}
\frametitle{The Naive Approach}
	\begin{block}{Additional SMT Constraint}
	\begin{equation}
		Total\ Number\ of\ crashes = k
	\end{equation} 
	\begin{flushright}
		where $k\in\{0,1,2...\}$
	\end{flushright}
	\end{block}
	\pause
	\begin{itemize}
	\item For successive $k\in\{0,1,2...\}$
	\begin{enumerate}
		\item Get a solution $\sigma$
		\item Calculate $\Pr(\sigma)$, subtract it from $Score(\text{Priority Scheme})$
		\item Add $\neg \sigma$ to the program as a constraint
		\item Repeat this process until there is no solution left
	\end{enumerate}
	\item Stop after reaching enough precision
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Naive Approach}
\framesubtitle{Optimization} 
	Identify and add minimal sub-constraint\\[2ex]
	Let $ \sigma \vDash f$\\
	\begin{itemize}
	\item Amongst the crashes occuring at $time=0,1,2,...$,\\
	Find the smallest $t_{doomed}$ such that\\
	Crashes occuring until $t_{doomed}$ are sufficient for $\neg\text{(All messages arrive by t)}$\\
	$$\text{Minimal sub-constraint} = \neg(\text{crashes occuring until }t_{doomed})$$
	\item This is done in practice by building a SMT Program for each $time\in\{0,1,2...\}$, which is UNSAT if Crashes occuring until $t_{doomed}$ are sufficient for $\neg\text{(All messages arrive by t)}$
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Just for Fun!}
	\begin{figure}
	\includegraphics[scale=0.7]{media/xkcd1.png}
	% \includegraphics[scale=0.4]{media/fun1.jpg}
	\caption{\tiny Source: xkcd.com}
	\end{figure}
\end{frame}

\begin{frame}
\frametitle{A Counting Approach}
	Build $ f $\ : SAT formula to simulate the netork.\\
	Every crash sequence \mapsto\ a unique assignment \sigma\  
	$$\sigma \vDash f \iff \text{All Message Arrive by time t}$$
	\vspace*{-15pt}
	\begin{block}{Recall}
	$$ Score(\text{Priority Scheme}) = \sum_{\sigma \vDash f}\Pr(\sigma) $$
	% $$\Pr(\sigma) = \prod_{l \in L}{\Pr(l=\sigma(l))}$$
	\end{block}
	\pause
	This is very similar to what Weighted Model Counting offers!
\end{frame}

\begin{frame}
\frametitle{A Counting Approach}
\framesubtitle{Weighted Model Counting (WMC)}

	WMC is a generalization of $SAT$ counting.\\
	\begin{block}{WMC}
	Let $f$ be a $SAT$ formula
	% \begin{eqnarray}
		$$WMC(f) = \sum_{\sigma \vDash f}Weight(\sigma)$$
		% $$Weight(\sigma) = \prod_{l \in L}{Weight(l=\sigma(l))}$$
	% \end{eqnarray}	
	\end{block}
\end{frame}

\begin{frame}
\frametitle{A Counting Approach}
\framesubtitle{Weighted Model Counting (WMC)}

	Each literal $l$\ is assigned a weight s.t.\\
	\vspace*{-5pt}
	$$Weight(l=True) + Weight(l=False) = 1$$\\
	% \vspace*{20pt}
	\begin{block}{WMC}
	Let $f$ be a $SAT$ formula, $\sigma$\ be a
	% \begin{eqnarray}
		% $$WMC(f) = \sum_{\sigma \vDash f}Weight(\sigma)$$
		$$Weight(\sigma) = \prod_{l \in L}{Weight(l=\sigma(l))}$$
	Thinking of $Weights$ as $Probabilities$,
		$$\ \ \ \ \ \ \ \  = \prod_{l \in L}{\Pr(l=\sigma(l))}$$
	% \end{eqnarray}	
	\end{block}
\end{frame}

\begin{frame}
\frametitle{A Counting Approach}
\framesubtitle{Weighted Model Counting (WMC)}

	\begin{block}{WMC}
	Let $f$ be a $SAT$ formula
	% \begin{eqnarray}
		$$WMC(f) = \sum_{\sigma \vDash f}Weight(\sigma)$$
		$$Weight(\sigma) = \prod_{l \in L}{Weight(l=\sigma(l))}$$
	% \end{eqnarray}	
	\end{block}
	Clearly, WMC can be directly used for models with independent random variables.\\
	% \vspace*{10pt}
	% Note that $paper^{2}$ only offers a reduction from WMC problems to Unweighted Model Counting.\\
	\pause
	\color{red}
	Our variables were not independent!\\
	We had to make modifications to use the WMC to UMC Reduction\footnote{\href{http://ijcai.org/Proceedings/15/Papers/103.pdf}{From Weighted to Unweighted Model Counting}}\\
\end{frame}

\begin{frame}
\frametitle{Other Approaches}
\framesubtitle{Bit-Adder}
	Build SMT formula $f$, as in the Naive Approach to simulate the network
	$\sigma \vDash f\  \to$\ crash sequences where All Messages don't arrive on time
	\begin{block}{Recall the only SMT Constraint...}
	$$Total\ Number\ of\ crashes = k$$
	\begin{flushright}
		where $k\in\{0,1,2...\}$
	\end{flushright}
	\end{block}

	\pause

	\begin{itemize}
	\item We simulate the execution of a bit-adder circuit
	\item Hence, convert this SMT constraint to a SAT constraint
	\item We now have a purely SAT formula
	\item Use a SAT counting tool, obtain probability bounds
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Other Approaches}
\framesubtitle{Monte-Carlo}
	Given $\epsilon \ and\ \delta$,\\
	Report $Score(\text{Priority Scheme})$ within an error $\epsilon$\ with a confidence $1-\delta$.\\[2ex]
	This is based on the Hoeffding's inequality.\\[2ex]
	Method:
	\begin{itemize}
	\item Simulate the network $n$\ times, randomly deciding faults
	\item Amongst the $n$\ trials, $k$\ trials are successful 
	\item $Score(\text{Priority Scheme}) \approx \frac{k}{n}$
	\item Use multiprocessing for faster results
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Counting Techniques}
	Approaches that need SAT counting:
	\begin{itemize}
		\item WMC Reduction
		\item Bit-Adder\\[2ex]
	\end{itemize}

	Different SAT counting tools tried:
	\begin{itemize}
	\item Exact
		\begin{itemize}
		\item SharpSAT\footnote{https://sites.google.com/site/marcthurley/sharpsat}*
		\end{itemize}

	\item Approximate
		\begin{itemize}
		\item Cryptominsat\footnote{https://github.com/msoos/cryptominisat}
		\item ApproxMC\footnote{https://www.cs.rice.edu/CS/Verification/Projects/ApproxMC/Paper.pdf}\\[3ex]
		\end{itemize}
	\end{itemize}
	*Gave the best results
\end{frame}

\begin{frame}
\frametitle{What Next?}
	\begin{itemize}
	\item Heuristics
		\begin{itemize}
		\item We have noticed some heuristics consistently lead to better priority schemes
		\end{itemize}
	\item Improving Priority Schemes
		\begin{itemize}
		\item Try to find ways to iteratively improve priority schemes
		\item Compare conditional probabilities of messages arriving on time
		\end{itemize}
	\item Finding Complexity Bounds
		\begin{itemize}
		\item Prove complexity bounds for this problem
		\end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Thank You}
% Questions?
% \Large{Questions?}
\end{frame}

\end{document} 