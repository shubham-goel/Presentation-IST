
\frametitle{Overview}
In this presentation, I will talk about:
1. A practical issue that needs to be addressed
2. What is our problem statement, how do we address that issue?
3. How did we solve that problem?
4. What next?

\frametitle{Motivation}
SHOW==================
A picture of a switched network

TALK ABOUT============
When a switch has a lot of packets(messages) in its queue, the order in which the messages are forwarded may adversely affect the performance of the network. Hence, it becomes important to know which 'priority schemes' are better and why. As the topic suggests, we define parameters which enable us to score priority schemes for comparison.

\frametitle{An Example}
This example will show how one priority scheme can better than another:

Vertices = [v0,v1,v2]
Edges = [e0=(v0,v1), e1=(v1,v2)]
Messages:
	m0
		source=v0
		target=v1
	m1
		source=v0
		target=v2

Clearly, all messages arrive at their targets quickly if m1 has higher priority than m0 at the first switch.

SHOW==================
A step by step description of the run-time configurations

TALK ABOUT============
The same

\frametitle{Initial Work??}
Where and how should I fit in the initial work? I'm referring to the work on the 'Schedule' model, possible optimizations by using the same solver, counting the number of solutions etc.

\frametitle{Definitions}
Path Protocol
-------------
	A protocol which specifies the path to be taken by a message
	For each message m<M, a path in G from its source (m.s) to target (m.t). Let us call this the message's highway.
	For each message m<M, each vertex v on m's highway, a fallback path from v to m.s, to be followed once the highway edges crash

Faults
------
	Omissions, Pr(Omission)
	Crashes, Pr()


\frametitle{Problem Statement}
SHOW==================
Given:
A directed graph G
A set of messages M
A path protocol P
A timeout T
Crash Probabilities

Find Pr(AMA)
where AMA is the event that All Messages Arrive on time

TALK ABOUT============
Represent the Network by a directed graph G,
And the packets by messages
The Same

\frametitle{The Naive Approach}
SHOW==================
A flowchart describing this:

Encode a forwarding algorithm and the path protocol an SMT Program which is SAT if there exists a sequence of crashes which result in $not(AMA)$

1. Use an SMT solver to get a solution, and the corresponding probability 
2. Add it's negation to the solver as a Constraint
3. Repeat this process until there is no solution left

TALK ABOUT============
The same

Optimization
------------
SHOW==================
The same slide as before, with a slight modification in the constraints, showing what the 'representation' of a minimal sub-constraint.

TALK ABOUT============
Instead of adding the whole constraint, we identify a minimal sub-constraint which is sufficient for $not(AMA)$
Why the naive approach cannot be scaled.
How program generation time of the possible optimization outweighs its benefits

\frametitle{Weighted Model Counting (WMC)}

\frametitle{Handling Dependent Variables with WMC}

\frametitle{Counting Techniques}
	Exact
	-----

	Approximate
	-----------

\frametitle{Bit-adder Approach}

\frametitle{Monte-Carlo Approach}
	Multiprocessing/threads
	-----------------------

\frametitle{Results/Scalability}

\frametitle{Already Extending The Problem Statement}
	Heuristics
	----------

\frametitle{What Is Next}
	Improving Priority Schemes
	--------------------------

	Finding Complexity Bounds
	-------------------------

